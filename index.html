<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>반짝 반짝 우주비행</title> <!-- 게임 제목 변경 -->
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN 로드 (사운드 효과용) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Firebase SDK 로드 (점수 랭킹용) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase 전역 변수 설정 (Canvas 환경에서 제공되는 값 사용)
        // __app_id, __firebase_config, __initial_auth_token은 Canvas 런타임에서 자동으로 주입됩니다.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase 초기화
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let userId = null; // 사용자 ID

        // 인증 상태 변경 리스너
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                console.log("Firebase authenticated. User ID:", userId);
                // 인증 완료 후 점수 로드 시작
                window.loadScores(); // 전역으로 노출된 함수 호출
            } else {
                // 인증 토큰이 없으면 익명으로 로그인 시도
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Firebase authentication failed:", error);
                }
            }
        });

        // 전역 스코프에 Firebase 관련 객체 노출 (메인 스크립트에서 접근 가능하도록)
        window.firebaseApp = app;
        window.firestoreDb = db;
        window.firebaseAuth = auth;
        window.getUserId = () => userId; // userId를 가져오는 함수

        // 게임 점수를 Firestore에 저장하는 함수
        window.saveGameScore = async (score, grade) => {
            if (!userId) {
                console.warn("User not authenticated. Cannot save score.");
                return;
            }
            try {
                // Firestore 보안 규칙에 따라 public 데이터 경로 사용
                const scoresCollectionRef = collection(db, `artifacts/${appId}/public/data/gameScores`);
                await addDoc(scoresCollectionRef, {
                    userId: userId,
                    score: score,
                    grade: grade,
                    timestamp: Date.now()
                });
                console.log("Score saved successfully!");
            } catch (e) {
                console.error("Error adding document to Firestore: ", e);
            }
        };

        // Firestore에서 점수를 로드하여 랭킹 보드를 업데이트하는 함수
        window.loadScores = () => {
            if (!db) {
                console.warn("Firestore is not initialized. Retrying loadScores in 1 second.");
                setTimeout(window.loadScores, 1000); // 1초 후 재시도
                return;
            }
            // Firestore 보안 규칙에 따라 public 데이터 경로 사용
            const scoresCollectionRef = collection(db, `artifacts/${appId}/public/data/gameScores`);
            // orderBy는 인덱스가 필요할 수 있으므로, 여기서는 사용하지 않고 클라이언트에서 정렬
            const q = query(scoresCollectionRef, limit(10)); // 상위 10개만 가져옴

            onSnapshot(q, (snapshot) => {
                const scores = [];
                snapshot.forEach((doc) => {
                    scores.push(doc.data());
                });
                // 점수를 내림차순으로 정렬 (클라이언트 측 정렬)
                scores.sort((a, b) => b.score - a.score);
                updateLeaderboard(scores);
            }, (error) => {
                console.error("Error fetching scores from Firestore: ", error);
            });
        };

        // 랭킹 보드 UI 업데이트 함수
        function updateLeaderboard(scores) {
            const leaderboardList = document.getElementById('leaderboardList');
            if (!leaderboardList) return;

            leaderboardList.innerHTML = ''; // 기존 목록 초기화
            scores.forEach((data, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'flex justify-between items-center py-1 px-2 rounded-md';
                if (index === 0) listItem.classList.add('bg-yellow-700', 'text-yellow-100'); // 1등 강조
                else if (index < 3) listItem.classList.add('bg-gray-700', 'text-gray-100'); // 2,3등 강조
                else listItem.classList.add('text-gray-200');

                // 사용자 ID 축약 및 현재 사용자 강조
                const displayName = data.userId ? data.userId.substring(0, 8) + '...' : 'Unknown';
                if (window.getUserId() && data.userId === window.getUserId()) {
                    listItem.classList.add('font-bold', 'text-blue-300'); // 현재 사용자 강조
                }

                listItem.innerHTML = `
                    <span>${index + 1}. ${displayName}</span>
                    <span>${data.score}점 (${data.grade})</span>
                `;
                leaderboardList.appendChild(listItem);
            });
            // 현재 사용자 ID 표시
            const currentUserIdDisplay = document.getElementById('currentUserId');
            if (currentUserIdDisplay && window.getUserId()) {
                currentUserIdDisplay.textContent = `내 ID: ${window.getUserId()}`;
            }
        }
    </script>
    <style>
        /* 기본 폰트 설정 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* 어두운 배경 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* 스크롤바 방지 */
            gap: 20px; /* 게임 컨테이너와 랭킹 보드 사이 간격 */
        }

        /* 게임 컨테이너 스타일 */
        .game-container {
            position: relative;
            width: 600px; /* 게임 영역의 너비 */
            height: 800px; /* 게임 영역의 높이 */
            background-color: #2d3748; /* 트랙 배경색 */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            overflow: hidden; /* 요소들이 컨테이너 밖으로 나가지 않도록 */
            border: 5px solid #4a5568;
            display: flex; /* 트랙을 위한 flexbox */
        }

        /* 트랙 스타일 */
        .track {
            flex: 1; /* 각 트랙이 동일한 너비를 가지도록 */
            border-right: 1px dashed rgba(255, 255, 255, 0.2); /* 트랙 구분선 */
            box-sizing: border-box;
            position: relative; /* 자식 요소의 absolute 위치를 위해 */
        }

        .track:last-child {
            border-right: none; /* 마지막 트랙은 구분선 없음 */
        }

        /* 플레이어 스타일 */
        .player {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #63b3ed; /* 플레이어 색상 (하늘색) */
            border-radius: 10px;
            bottom: 100px; /* 화면 하단에서 조금 위로 */
            transition: left 0.15s ease-in-out; /* 부드러운 좌우 이동 */
            box-shadow: 0 0 15px rgba(99, 179, 237, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 25px;
            color: white;
            z-index: 10; /* 플레이어가 다른 요소 위에 오도록 */
        }

        /* 장애물 스타일 */
        .obstacle {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: #e53e3e; /* 장애물 색상 (빨간색) */
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(229, 62, 62, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            color: white;
            font-weight: bold;
            z-index: 5;
            transition: transform 0.1s ease-out, opacity 0.1s ease-out; /* 파괴 애니메이션용 */
        }

        /* 장애물 파괴 효과 */
        .obstacle.destroyed {
            transform: scale(0.5);
            opacity: 0;
        }

        /* 아이템 스타일 */
        .item {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%; /* 젤리 모양 */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
            z-index: 5;
        }

        /* 점수 아이템 (젤리) */
        .item.score {
            background-color: #f6ad55; /* 주황색 젤리 */
            box-shadow: 0 0 10px rgba(246, 173, 85, 0.7);
        }

        /* 자력 아이템 */
        .item.magnet {
            background-color: #48bb78; /* 초록색 자석 */
            box-shadow: 0 0 10px rgba(72, 187, 120, 0.7);
        }

        /* BONUS 글자 아이템 */
        .item.bonus {
            background-color: #805ad5; /* 보라색 글자 */
            border-radius: 5px; /* 사각형 모양 */
            box-shadow: 0 0 10px rgba(128, 90, 213, 0.7);
            font-size: 20px;
        }

        /* 시간 증가 아이템 */
        .item.time-increase {
            background-color: #a0aec0; /* 회색 시계 */
            box-shadow: 0 0 10px rgba(160, 174, 192, 0.7);
            font-size: 24px;
        }

        /* 무지개 점수 아이템 (피버 모드용) */
        .item.rainbow-score {
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            font-size: 30px;
            animation: rainbowGlow 1.5s infinite alternate;
        }

        @keyframes rainbowGlow {
            from { box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
            to { box-shadow: 0 0 30px rgba(255, 255, 255, 1); }
        }


        /* UI 정보 패널 */
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center; /* 세로 중앙 정렬 */
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            z-index: 20;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 8px 12px;
            border-radius: 8px;
            white-space: nowrap; /* 글자들이 줄바꿈되지 않도록 */
        }

        .info-panel span {
            margin-right: 15px;
        }

        /* BONUS 글자 컨테이너 */
        #bonusLettersContainer {
            display: flex;
            align-items: center;
            gap: 5px; /* 글자 사이 간격 */
        }

        /* 개별 BONUS 글자 스타일 */
        #bonusLettersContainer .bonus-letter {
            font-size: 1.1rem;
            font-weight: bold;
            color: #a0aec0; /* 기본 회색 */
            transition: color 0.2s ease-in-out, text-shadow 0.2s ease-in-out;
        }

        /* 획득한 BONUS 글자 스타일 */
        #bonusLettersContainer .bonus-letter.collected {
            color: #fbd38d; /* 노란색으로 빛나는 효과 */
            text-shadow: 0 0 8px #fbd38d, 0 0 15px #fbd38d;
        }


        /* 게임 오버 메시지 */
        .game-over-message {
            position: absolute;
            top: 40%; /* 위치 조정 */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.5rem;
            font-weight: bold;
            color: #e53e3e; /* 빨간색 */
            text-shadow: 0 0 20px rgba(229, 62, 62, 0.8);
            z-index: 100;
            display: none; /* 초기에는 숨김 */
            animation: pulse 1.5s infinite alternate; /* 깜빡이는 효과 */
            text-align: center; /* 텍스트 중앙 정렬 */
            white-space: nowrap; /* 줄바꿈 방지 */
        }

        /* 등급 표시 */
        .grade-display {
            font-size: 2.5rem; /* 등급 글자 크기 */
            margin-top: 10px; /* 게임 오버 메시지와의 간격 */
            color: #fbd38d; /* 등급 색상 (노란색) */
            text-shadow: 0 0 15px rgba(251, 211, 141, 0.8);
        }


        /* 깜빡이는 애니메이션 */
        @keyframes pulse {
            from { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* 피버 타임 효과 */
        .fever-effect {
            animation: feverGlow 0.5s infinite alternate;
            box-shadow: 0 0 30px #fbd38d, 0 0 40px #fbd38d, 0 0 50px #fbd38d;
        }

        @keyframes feverGlow {
            from { box-shadow: 0 0 30px #fbd38d, 0 0 40px #fbd38d, 0 0 50px #fbd38d; }
            to { box-shadow: 0 0 20px #fbd38d, 0 0 30px #fbd38d, 0 0 40px #fbd38d; }
        }

        /* 자력 효과 시 아이템 끌어당기는 애니메이션 */
        .attracted {
            transition: transform 0.2s ease-out;
        }

        /* 시작 버튼 및 재시작 버튼 */
        .start-button, .restart-button {
            position: absolute;
            top: 60%; /* 위치 조정 */
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            background-color: #48bb78;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s ease, transform 0.2s ease;
            z-index: 101;
        }

        .start-button:hover, .restart-button:hover {
            background-color: #38a169;
            transform: translate(-50%, -50%) scale(1.05);
        }

        /* 랭킹 보드 스타일 */
        .leaderboard-container {
            width: 300px; /* 랭킹 보드 너비 */
            height: 800px; /* 게임 컨테이너와 동일한 높이 */
            background-color: #2d3748;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border: 5px solid #4a5568;
            padding: 20px;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .leaderboard-container h2 {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #fbd38d;
        }

        .leaderboard-container ul {
            list-style: none;
            padding: 0;
            width: 100%;
        }

        .leaderboard-container li {
            background-color: rgba(0, 0, 0, 0.3);
            margin-bottom: 8px;
            border-radius: 5px;
            font-size: 1rem;
        }

        .current-user-id {
            margin-top: auto; /* 하단에 배치 */
            font-size: 0.9rem;
            color: #a0aec0; /* 회색 텍스트 */
            text-align: center;
            width: 100%;
            padding-top: 10px;
            border-top: 1px dashed rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div class="game-container" id="gameContainer">
        <div class="info-panel">
            <span>점수: <span id="score">0</span></span>
            <span>체력: <span id="health">3</span></span>
            <span>콤보: <span id="combo">0</span></span>
            <span>시간: <span id="time">60</span>s</span>
            <div id="bonusLettersContainer" class="ml-auto"></div> <!-- BONUS 글자 컨테이너 -->
        </div>
        <div class="track"></div>
        <div class="track"></div>
        <div class="track"></div>
        <div class="player" id="player">🚀</div>
        <div class="game-over-message" id="gameOverMessage">
            GAME OVER
            <div id="finalScoreDisplay" class="grade-display"></div>
            <div id="gradeDisplay" class="grade-display"></div>
        </div>
        <button class="start-button" id="startButton">게임 시작</button>
        <button class="restart-button" id="restartButton" style="display: none;">다시 시작</button>
    </div>

    <!-- 랭킹 보드 컨테이너 -->
    <div class="leaderboard-container">
        <h2>🏆 최고 점수 랭킹</h2>
        <ul id="leaderboardList">
            <!-- 랭킹 아이템들이 여기에 동적으로 추가됩니다. -->
            <li>랭킹 로딩 중...</li>
        </ul>
        <div id="currentUserId" class="current-user-id">내 ID: 로딩 중...</div>
    </div>

    <!-- 배경 음악 플레이어 -->
    <audio id="backgroundMusic" loop volume="0.3">
        <!-- Royalty Free Game Music (Replace with your preferred URL) -->
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script>
        // 게임 요소 가져오기
        const gameContainer = document.getElementById('gameContainer');
        const player = document.getElementById('player');
        const scoreDisplay = document.getElementById('score');
        const healthDisplay = document.getElementById('health');
        const comboDisplay = document.getElementById('combo');
        const timeDisplay = document.getElementById('time'); // 시간 표시
        const bonusLettersContainer = document.getElementById('bonusLettersContainer'); // BONUS 글자 컨테이너
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay'); // 최종 점수 표시
        const gradeDisplay = document.getElementById('gradeDisplay'); // 등급 표시
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');

        // 배경 음악 요소
        const backgroundMusic = document.getElementById('backgroundMusic');

        // 🎶 사운드 효과 (Tone.js)
        let itemCollectSynth;
        let obstacleDestroySynth;

        // 게임 설정 변수
        let LANE_WIDTH; // gameContainer.offsetWidth에 따라 동적으로 계산됩니다.
        const PLAYER_SIZE = 50;
        const OBSTACLE_SIZE = 60;
        const ITEM_SIZE = 40;
        const PLAYER_BOTTOM_OFFSET = 100;

        let currentLane = 1;
        let score = 0;
        let health = 3;
        let combo = 0;
        const COMBO_RESET_ON_MISS = true; // 콤보가 아이템 놓칠 때만 초기화되도록

        let obstacles = [];
        let items = [];

        let initialGameSpeed = 11; // 초기 게임 속도 (수정됨: 10 -> 11)
        let gameSpeed = initialGameSpeed;
        const SPEED_INCREASE_RATE = 0.005; // 게임 진행에 따른 속도 증가율 (수정됨: 0.004 -> 0.005)
        const SPEED_DECREASE_ON_HIT = 1.5;
        const MIN_GAME_SPEED = 2;

        let itemSpawnInterval = 400; // 아이템/장애물 생성 간격 (ms, 수정됨: 450 -> 400)
        let lastSpawnTime = 0;

        let isGameOver = false;
        let isGameRunning = false;
        let animationFrameId;

        let sessionCollectedBonusLetters = new Set(); // 현재 게임 세션에서 획득한 BONUS 글자
        const ALL_BONUS_LETTERS = ['B', 'O', 'N', 'U', 'S'];
        let isFeverTime = false;
        let feverTimeDuration = 5000; // 피버 타임 지속 시간 5초
        let feverTimeTimeoutId;

        let isMagnetActive = false;
        let magnetDuration = 5000; // 자력 아이템 지속 시간 5초 (피버 모드와 동일하게)
        let magnetTimeoutId;
        const MAGNET_RANGE_NORMAL = 150; // 일반 자력 아이템의 범위
        const MAGNET_RANGE_FEVER = 350; // 피버 타임 시 자력 아이템의 범위 (수정됨: 150 -> 350)
        let currentMagnetRange = MAGNET_RANGE_NORMAL; // 현재 적용되는 자석 범위

        let gameStartTime = 0;
        let gameCurrentTime = 0; // 게임 내 현재 시간 (밀리초)
        const GAME_DURATION = 60 * 1000; // 게임 제한 시간 1분 (ms)
        const TIME_INCREASE_AMOUNT = 10 * 1000; // 시간 증가 아이템 획득 시 10초 증가

        const OBSTACLE_EMOJIS = ['🚧', '🚨', '🛑', ' ', '❌', '💣', '💥', '🔥', '☄️', '🛰️']; // 다양한 장애물 이모지 추가

        // Tone.js 사운드 초기화
        async function initializeSounds() {
            // 웹 오디오 API는 사용자 상호작용 후에 활성화되어야 합니다.
            // Tone.start()는 AudioContext를 활성화합니다.
            document.documentElement.addEventListener('mousedown', () => {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                    console.log("AudioContext started");
                }
            });
            document.documentElement.addEventListener('keydown', () => {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                    console.log("AudioContext started");
                }
            });

            itemCollectSynth = new Tone.Synth({
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.05,
                    release: 0.1
                }
            }).toDestination();

            obstacleDestroySynth = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.01,
                    release: 0.3
                }
            }).toDestination();
        }

        // 플레이어 초기 위치 설정
        function initializePlayerPosition() {
            LANE_WIDTH = gameContainer.offsetWidth / 3;
            player.style.left = `${currentLane * LANE_WIDTH + (LANE_WIDTH / 2) - (PLAYER_SIZE / 2)}px`;
            player.style.bottom = `${PLAYER_BOTTOM_OFFSET}px`;
        }

        // 게임 초기화
        function initializeGame() {
            score = 0;
            health = 3;
            combo = 0;
            currentLane = 1;
            obstacles = [];
            items = [];
            sessionCollectedBonusLetters.clear(); // 게임 시작 시 BONUS 글자 초기화
            isGameOver = false;
            isGameRunning = false;
            gameSpeed = initialGameSpeed; // 초기 속도로 재설정
            itemSpawnInterval = 400; // 초기 생성 간격으로 재설정
            lastSpawnTime = 0;
            isFeverTime = false;
            isMagnetActive = false;
            currentMagnetRange = MAGNET_RANGE_NORMAL; // 자석 범위 초기화
            gameStartTime = 0;
            gameCurrentTime = GAME_DURATION; // 게임 내 현재 시간 초기화

            scoreDisplay.textContent = score;
            healthDisplay.textContent = health;
            comboDisplay.textContent = combo;
            timeDisplay.textContent = GAME_DURATION / 1000;
            updateBonusLettersDisplay(); // BONUS 글자 UI 초기화
            gameOverMessage.style.display = 'none';
            player.classList.remove('fever-effect');
            restartButton.style.display = 'none';
            startButton.style.display = 'block';

            document.querySelectorAll('.obstacle, .item').forEach(el => el.remove());

            initializePlayerPosition();
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0; // 음악 처음으로 되감기
            backgroundMusic.playbackRate = 1.0; // 음악 재생 속도 초기화
        }

        // 게임 시작
        function startGame() {
            if (isGameRunning) return;

            isGameRunning = true;
            startButton.style.display = 'none';
            restartButton.style.display = 'none';
            gameOverMessage.style.display = 'none';
            gameStartTime = performance.now();
            // gameCurrentTime은 initializeGame에서 이미 설정됨

            animationFrameId = requestAnimationFrame(gameLoop);
            lastSpawnTime = performance.now();

            // 배경 음악 재생 (사용자 상호작용 후)
            backgroundMusic.play().catch(error => {
                console.warn("배경 음악 자동 재생 실패:", error);
            });
        }

        // 게임 루프
        function gameLoop(currentTime) {
            if (isGameOver || !isGameRunning) {
                return;
            }

            const deltaTime = currentTime - (gameLoop.lastTime || currentTime);
            gameLoop.lastTime = currentTime;

            gameCurrentTime -= deltaTime; // 남은 시간 감소
            const remainingTimeSeconds = Math.max(0, Math.ceil(gameCurrentTime / 1000));
            timeDisplay.textContent = remainingTimeSeconds;

            if (remainingTimeSeconds <= 0) {
                gameOver();
                return;
            }

            gameSpeed += SPEED_INCREASE_RATE * (deltaTime / 1000); // deltaTime을 사용하여 프레임 속도에 독립적인 속도 증가

            // 음악 재생 속도 조절
            const basePlaybackRate = 1.0;
            const speedFactor = (gameSpeed - initialGameSpeed) * 0.15; // 속도에 비례하여 증가하는 비율
            backgroundMusic.playbackRate = Math.min(3.0, basePlaybackRate + speedFactor); // 최대 3.0배까지

            // 아이템 스폰 간격을 게임 속도에 따라 조절 (더 빠르게 스폰)
            const currentItemSpawnInterval = Math.max(150, itemSpawnInterval - (gameSpeed * 10)); // 최소 150ms (수정됨: 200 -> 150)
            if (currentTime - lastSpawnTime > currentItemSpawnInterval) {
                spawnRandomObject();
                lastSpawnTime = currentTime;
            }

            moveObjects();
            checkCollisions();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // 플레이어 좌우 이동
        function movePlayer(direction) {
            if (isGameOver) return;

            const newLane = currentLane + direction;
            if (newLane >= 0 && newLane <= 2) {
                currentLane = newLane;
                player.style.left = `${currentLane * LANE_WIDTH + (LANE_WIDTH / 2) - (PLAYER_SIZE / 2)}px`;
            }
        }

        // 키보드 이벤트 핸들러
        document.addEventListener('keydown', (e) => {
            if (!isGameRunning && e.key === ' ') {
                startGame();
                return;
            }
            if (isGameOver && e.key === 'r') {
                restartGame();
                return;
            }

            if (!isGameRunning || isGameOver) return;

            if (e.key === 'ArrowLeft') {
                movePlayer(-1);
            } else if (e.key === 'ArrowRight') {
                movePlayer(1);
            }
        });

        // 랜덤 객체 (아이템 또는 장애물) 생성
        function spawnRandomObject() {
            LANE_WIDTH = gameContainer.offsetWidth / 3;

            // 피버 타임 중에는 모든 트랙에 무지개 점수 아이템만 생성
            if (isFeverTime) {
                for (let i = 0; i < 3; i++) { // 각 트랙에 하나씩
                    const objectElement = document.createElement('div');
                    objectElement.classList.add('item', 'rainbow-score');
                    objectElement.textContent = '🌈';
                    objectElement.dataset.type = 'rainbow-score';
                    objectElement.style.width = `${ITEM_SIZE + 10}px`;
                    objectElement.style.height = `${ITEM_SIZE + 10}px`;
                    const leftPosition = i * LANE_WIDTH + (LANE_WIDTH / 2);
                    objectElement.style.left = `${leftPosition - ((ITEM_SIZE + 10) / 2)}px`;
                    objectElement.style.top = `-100px`; // 화면 위에서 시작
                    items.push(objectElement);
                    gameContainer.appendChild(objectElement);
                }
                return; // 피버 중에는 다른 아이템/장애물 생성 안 함
            }

            // 일반 아이템 또는 장애물 생성
            const lane = Math.floor(Math.random() * 3);
            const objectElement = document.createElement('div');
            objectElement.style.top = `-100px`;
            const leftPosition = lane * LANE_WIDTH + (LANE_WIDTH / 2);

            const typeRoll = Math.random();
            let type;
            if (typeRoll < 0.80) { // 80% 확률로 아이템
                type = 'item';
            } else { // 20% 확률로 장애물
                type = 'obstacle';
            }

            if (type === 'obstacle') {
                objectElement.classList.add('obstacle');
                objectElement.textContent = OBSTACLE_EMOJIS[Math.floor(Math.random() * OBSTACLE_EMOJIS.length)]; // 다양한 장애물
                objectElement.dataset.isMovingHorizontally = 'true'; // 모든 장애물이 좌우로 움직임
                objectElement.dataset.horizontalSpeed = (Math.random() * 2 + 1).toFixed(2); // 1.0 ~ 3.0
                objectElement.dataset.horizontalDirection = Math.random() < 0.5 ? '1' : '-1';
                objectElement.style.width = `${OBSTACLE_SIZE}px`;
                objectElement.style.height = `${OBSTACLE_SIZE}px`;
                objectElement.style.left = `${leftPosition - (OBSTACLE_SIZE / 2)}px`;
                obstacles.push(objectElement);
            } else { // type === 'item'
                objectElement.classList.add('item');
                objectElement.style.width = `${ITEM_SIZE}px`;
                objectElement.style.height = `${ITEM_SIZE}px`;
                objectElement.style.left = `${leftPosition - (ITEM_SIZE / 2)}px`;

                const itemTypeRoll = Math.random();
                if (itemTypeRoll < 0.72) { // 72% for score (수정됨: 60% -> 72%)
                    objectElement.classList.add('score');
                    objectElement.textContent = '⭐';
                    objectElement.dataset.type = 'score';
                    objectElement.dataset.collected = 'false';
                } else if (itemTypeRoll < 0.80) { // 8% for magnet (수정됨: 15% -> 8%)
                    objectElement.classList.add('magnet');
                    objectElement.textContent = '🧲';
                    objectElement.dataset.type = 'magnet';
                } else if (itemTypeRoll < 0.98) { // 18% for bonus (수정됨: 15% -> 18%)
                    // 현재 세션에서 아직 획득하지 않은 BONUS 글자만 생성
                    const availableLetters = ALL_BONUS_LETTERS.filter(letter => !sessionCollectedBonusLetters.has(letter));
                    if (availableLetters.length > 0) {
                        const randomLetter = availableLetters[Math.floor(Math.random() * availableLetters.length)];
                        objectElement.classList.add('bonus');
                        objectElement.textContent = randomLetter;
                        objectElement.dataset.type = 'bonus';
                        objectElement.dataset.letter = randomLetter;
                    } else {
                        // 모든 BONUS 글자를 모았다면 점수 아이템으로 대체
                        objectElement.classList.add('score');
                        objectElement.textContent = '⭐';
                        objectElement.dataset.type = 'score';
                        objectElement.dataset.collected = 'false';
                    }
                } else { // 2% for time-increase (수정됨: 10% -> 2%)
                    objectElement.classList.add('time-increase');
                    objectElement.textContent = '⏱️';
                    objectElement.dataset.type = 'time-increase';
                }
                items.push(objectElement);
            }
            gameContainer.appendChild(objectElement);
        }

        // 모든 객체 이동
        function moveObjects() {
            // 장애물 이동
            obstacles.forEach((obstacle, index) => {
                let currentTop = parseFloat(obstacle.style.top);
                obstacle.style.top = `${currentTop + gameSpeed}px`;

                // 수평 이동하는 장애물 처리
                if (obstacle.dataset.isMovingHorizontally === 'true') {
                    let currentLeft = parseFloat(obstacle.style.left);
                    let horizontalSpeed = parseFloat(obstacle.dataset.horizontalSpeed);
                    let horizontalDirection = parseInt(obstacle.dataset.horizontalDirection);

                    // 장애물이 트랙 중앙에 생성되므로, 트랙의 왼쪽/오른쪽 경계를 기준으로 움직이도록 계산
                    const obstacleWidth = parseFloat(obstacle.style.width);
                    const laneIndex = Math.floor((currentLeft + obstacleWidth / 2) / LANE_WIDTH);
                    const laneLeftBoundary = laneIndex * LANE_WIDTH;
                    const laneRightBoundary = (laneIndex + 1) * LANE_WIDTH - obstacleWidth;

                    let newLeft = currentLeft + horizontalSpeed * horizontalDirection;

                    // 트랙 경계에 도달하면 방향 반전
                    if (newLeft <= laneLeftBoundary || newLeft >= laneRightBoundary) {
                        horizontalDirection *= -1;
                        obstacle.dataset.horizontalDirection = horizontalDirection;
                        newLeft = currentLeft + horizontalSpeed * horizontalDirection; // 방향 바꾼 후 다시 계산
                    }
                    obstacle.style.left = `${newLeft}px`;
                }


                // 화면 밖으로 나간 장애물 제거
                if (currentTop > gameContainer.offsetHeight) {
                    obstacle.remove();
                    obstacles.splice(index, 1);
                }
            });

            // 아이템 이동
            items.forEach((item, index) => {
                let currentTop = parseFloat(item.style.top);

                // 자력 아이템 활성화 시 끌어당기기
                if (isMagnetActive && (item.dataset.type === 'score' || item.dataset.type === 'rainbow-score' || item.dataset.type === 'magnet' || item.dataset.type === 'bonus' || item.dataset.type === 'time-increase')) {
                    const playerRect = player.getBoundingClientRect();
                    const itemRect = item.getBoundingClientRect();

                    const gameContainerRect = gameContainer.getBoundingClientRect();
                    const playerCenterX = (playerRect.left + playerRect.width / 2) - gameContainerRect.left;
                    const playerCenterY = (playerRect.top + playerRect.height / 2) - gameContainerRect.top;
                    const itemCenterX = (itemRect.left + itemRect.width / 2) - gameContainerRect.left;
                    const itemCenterY = (itemRect.top + itemRect.height / 2) - gameContainerRect.top;


                    const distanceX = playerCenterX - itemCenterX;
                    const distanceY = playerCenterY - itemCenterY;
                    const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

                    // 현재 자석 범위 사용
                    if (distance < currentMagnetRange) {
                        const attractionSpeed = 10; // 자력 속도 더 강하게
                        item.style.left = `${parseFloat(item.style.left) + distanceX / distance * attractionSpeed}px`;
                        item.style.top = `${currentTop + distanceY / distance * attractionSpeed + gameSpeed}px`;
                        item.classList.add('attracted');
                    } else {
                        item.style.top = `${currentTop + gameSpeed}px`;
                        item.classList.remove('attracted');
                    }
                } else {
                    item.style.top = `${currentTop + gameSpeed}px`;
                    item.classList.remove('attracted');
                }

                // 화면 밖으로 나간 아이템 제거 및 콤보 초기화
                if (currentTop > gameContainer.offsetHeight) {
                    if ((item.dataset.type === 'score' || item.dataset.type === 'rainbow-score') && item.dataset.collected === 'false' && COMBO_RESET_ON_MISS) {
                        combo = 0; // 점수 아이템을 놓치면 콤보 초기화
                        comboDisplay.textContent = combo;
                    }
                    item.remove();
                    items.splice(index, 1);
                }
            });
        }

        // 충돌 감지
        function checkCollisions() {
            const playerRect = player.getBoundingClientRect();

            // 장애물 충돌 확인
            obstacles.forEach((obstacle, index) => {
                const obstacleRect = obstacle.getBoundingClientRect();

                if (
                    playerRect.left < obstacleRect.right &&
                    playerRect.right > obstacleRect.left &&
                    playerRect.top < obstacleRect.bottom &&
                    playerRect.bottom > obstacleRect.top
                ) {
                    // 충돌 발생
                    if (isFeverTime) {
                        // 피버 타임 중에는 장애물 파괴 연출 및 소리
                        obstacle.classList.add('destroyed'); // 파괴 애니메이션 클래스 추가
                        obstacleDestroySynth.triggerAttackRelease("C2", "8n"); // 파괴 소리
                        setTimeout(() => {
                            obstacle.remove();
                            obstacles.splice(index, 1);
                        }, 100); // 애니메이션 지속 시간 후 제거
                    } else {
                        health--;
                        healthDisplay.textContent = health;
                        obstacle.remove();
                        obstacles.splice(index, 1);
                        combo = 0;
                        comboDisplay.textContent = combo;
                        gameSpeed = Math.max(MIN_GAME_SPEED, gameSpeed - SPEED_DECREASE_ON_HIT);

                        if (health <= 0) {
                            gameOver();
                        }
                    }
                }
            });

            // 아이템 충돌 확인
            items.forEach((item, index) => {
                const itemRect = item.getBoundingClientRect();

                if (
                    playerRect.left < itemRect.right &&
                    playerRect.right > itemRect.left &&
                    playerRect.top < itemRect.bottom &&
                    playerRect.bottom > itemRect.top
                ) {
                    // 아이템 획득
                    handleItemCollection(item);
                    item.remove();
                    items.splice(index, 1);
                }
            });
        }

        // 아이템 획득 처리
        function handleItemCollection(item) {
            const type = item.dataset.type;
            const currentTime = performance.now();

            if (type === 'score') {
                item.dataset.collected = 'true';
                score += 1000;
                combo++;
                score += combo * 100;
                lastItemCollectedTime = currentTime;
                scoreDisplay.textContent = score;
                comboDisplay.textContent = combo;
                itemCollectSynth.triggerAttackRelease("C5", "16n"); // 아이템 획득 소리
            } else if (type === 'magnet') {
                activateMagnet();
                itemCollectSynth.triggerAttackRelease("E5", "16n"); // 자력 아이템 획득 소리
            } else if (type === 'bonus') {
                const letter = item.dataset.letter;
                if (!sessionCollectedBonusLetters.has(letter)) { // 현재 세션에서 처음 획득하는 글자인지 확인
                    sessionCollectedBonusLetters.add(letter); // 세션에 추가
                    updateBonusLettersDisplay(); // BONUS 글자 UI 업데이트
                    itemCollectSynth.triggerAttackRelease("G5", "16n"); // 보너스 아이템 획득 소리
                    if (sessionCollectedBonusLetters.size === ALL_BONUS_LETTERS.length) {
                        activateFeverTime();
                    }
                }
            } else if (type === 'time-increase') { // 시간 증가 아이템
                gameCurrentTime += TIME_INCREASE_AMOUNT; // 남은 시간 증가 효과
                timeDisplay.textContent = Math.ceil(gameCurrentTime / 1000);
                itemCollectSynth.triggerAttackRelease("F#5", "16n"); // 시간 아이템 획득 소리
            } else if (type === 'rainbow-score') { // 무지개 점수 아이템
                score += 5000; // 더 높은 점수
                scoreDisplay.textContent = score;
                itemCollectSynth.triggerAttackRelease("G6", "16n"); // 무지개 아이템 획득 소리 (더 높은 음)
            }
        }

        // BONUS 글자 UI 업데이트 (개별 글자 불 들어오는 효과)
        function updateBonusLettersDisplay() {
            bonusLettersContainer.innerHTML = ''; // 기존 내용 초기화
            ALL_BONUS_LETTERS.forEach(letter => {
                const span = document.createElement('span');
                span.textContent = letter;
                span.classList.add('bonus-letter'); // 기본 스타일 클래스
                if (sessionCollectedBonusLetters.has(letter)) { // 세션 획득 여부 확인
                    span.classList.add('collected'); // 획득 시 불 들어오는 효과 클래스
                }
                bonusLettersContainer.appendChild(span);
            });
        }

        // 자력 아이템 활성화
        function activateMagnet() {
            if (isMagnetActive) {
                clearTimeout(magnetTimeoutId);
            }
            isMagnetActive = true;
            currentMagnetRange = MAGNET_RANGE_NORMAL; // 일반 자석 아이템 획득 시 일반 범위 적용
            magnetTimeoutId = setTimeout(() => {
                isMagnetActive = false;
            }, magnetDuration);
        }

        // 피버 타임 활성화
        function activateFeverTime() {
            if (isFeverTime) return;

            isFeverTime = true;
            gameSpeed *= 2; // 속도 200% 증가
            player.classList.add('fever-effect');
            isMagnetActive = true; // 피버 모드 시 자석 활성화
            currentMagnetRange = MAGNET_RANGE_FEVER; // 피버 타임 시 자석 범위 대폭 확대

            // 피버 타임 시작 시, BONUS 글자 불빛이 서서히 원래대로 돌아오도록
            // 피버 타임이 끝날 때 collected 클래스를 제거하여 불빛을 끕니다.
            feverTimeTimeoutId = setTimeout(() => {
                deactivateFeverTime();
                // 피버 타임 종료 시 모든 BONUS 글자의 collected 클래스 제거
                document.querySelectorAll('#bonusLettersContainer .bonus-letter').forEach(span => {
                    span.classList.remove('collected');
                });
            }, feverTimeDuration);
        }

        // 피버 타임 비활성화
        function deactivateFeverTime() {
            isFeverTime = false;
            gameSpeed /= 2; // 속도 원상 복구
            player.classList.remove('fever-effect');
            isMagnetActive = false; // 피버 모드 종료 시 자석 비활성화
            currentMagnetRange = MAGNET_RANGE_NORMAL; // 자석 범위 원상 복구
        }

        // 등급 계산 함수
        function calculateGrade(finalScore) {
            if (finalScore >= 100000) return 'SSS';
            else if (finalScore >= 80000) return 'SS';
            else if (finalScore >= 60000) return 'S';
            else if (finalScore >= 40000) return 'A';
            else if (finalScore >= 20000) return 'B';
            else if (finalScore >= 10000) return 'C';
            else if (finalScore >= 5000) return 'D';
            else return 'F';
        }

        // 게임 오버
        function gameOver() {
            isGameOver = true;
            isGameRunning = false;
            cancelAnimationFrame(animationFrameId);
            clearTimeout(feverTimeTimeoutId);
            clearTimeout(magnetTimeoutId);

            const finalScore = score;
            const grade = calculateGrade(finalScore);

            finalScoreDisplay.textContent = `최종 점수: ${finalScore}`;
            gradeDisplay.textContent = `등급: ${grade}`;
            gameOverMessage.style.display = 'block';
            restartButton.style.display = 'block';

            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
            backgroundMusic.playbackRate = 1.0; // 음악 재생 속도 초기화

            // 게임 오버 시 모든 BONUS 글자 불빛 끄기
            document.querySelectorAll('#bonusLettersContainer .bonus-letter').forEach(span => {
                span.classList.remove('collected');
            });

            // 점수 랭킹 저장 (window 객체에 노출된 함수 사용)
            if (window.saveGameScore) {
                window.saveGameScore(finalScore, grade);
            } else {
                console.error("saveGameScore function is not available.");
            }
        }

        // 게임 재시작
        function restartGame() {
            initializeGame();
            startGame();
        }

        // 이벤트 리스너 연결
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame);

        // 페이지 로드 시 초기화
        window.onload = () => {
            initializeSounds(); // 사운드 초기화
            initializeGame();
            // Firebase 로딩이 완료되면 loadScores가 자동으로 호출됩니다.
        };
    </script>
</body>
</html>
